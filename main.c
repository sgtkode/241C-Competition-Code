#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderL,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  ledMed,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  ledHigh,        sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  flyR2IEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  flyL2IEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           flyR1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           flyR2,         tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           flyL1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           flyL2,         tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           frontl,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           frontr,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           backl,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backr,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           topIntake,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          bottomIntake,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * @file    main.c
 * @brief   This file contains the base for competiton code.
 * @details The three sections include Pre-Auton, Auton, and User
 *          Control.
 *
 * @author		Sean Kelley      sgtkode01@gmail.com
 * @author		Bernard Suwirjo  bsuwirjo@gmail.com
 * @author 		Spencer Couture  spence.couture@gmail.com
 */


#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// all functions for competition code
#include "functions.c"

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Global Variables
//
/////////////////////////////////////////////////////////////////////////////////////////

bool highSpeedUpBtnPrsd = false; /*!< boolean that prevents astronomical increase from prolonged button press */
bool highSpeedDownBtnPrsd = false; /*!< boolean that prevents astronomical decrease from prolonged button press */
bool halfSpeedBtnPrsd = false; /*!< boolean that prevents astronomical change from prolonged button press */

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Pre-Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period before autonomous when bot cannot move, but minimal code can run
 */
void pre_auton()
{
 bStopTasksBetweenModes = true;
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period of match when bot is using only code to operate.
 */
task autonomous(){

	// allow motors to be controller by variables
	startTask(runMotors);

	// position of bot on field
	int position = 1;

	if(position == 1){ // blue, net side

		//spin_flywheel(0, 75, 300);
		//motor[bottomIntake] = 100;
		//wait1Msec(10000);

		//forwardSeconds(1);
	} else if(position == 2){ // blue, enemy side

		//spin_flywheel(0, 75, 300);
		motor[bottomIntake] = 100;
		wait1Msec(10000);

	} else if(position == 3){ // red, net side

		//spin_flywheel(0, 75, 300);
		motor[bottomIntake] = 100;
		wait1Msec(10000);

	} else if(position == 4){ // red, enemy side

		//spin_flywheel(0, 75, 300);
		motor[bottomIntake] = 100;
		wait1Msec(10000);

	} else if(position == 5){ // testing bruh

		/*motor[flyR1] = 120;
		wait1Msec(1000);
		motor[flyR1] = 0;
		motor[flyR2] = 120;
		wait1Msec(1000);
		motor[flyR2] = 0;
		motor[flyL1] = 120;
		wait1Msec(1000);
		motor[flyL1] = 0;
		motor[flyL2] = 120;
		wait1Msec(1000);
		motor[flyL2] = 0;*/
		startTask(spin_flywheel);
		FW_running = true;

	}
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period of match when driver controls the bot
 */
task usercontrol(){

	SensorValue[ledMed] = 0;
	SensorValue[ledHigh] = 0;
	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;

  while (true)
	{
    if(bVEXNETActive){


      /////////////////////////////////////////////////////////////////////////////////////////
      //
      //                                      Drive
      //
      /////////////////////////////////////////////////////////////////////////////////////////
  		/*if((abs(SensorValue[encoderL]) - abs(SensorValue[encoderR])) > 10){
				motor[backr] = vexRT[Ch2];
	  		motor[frontr] = vexRT[Ch2];
	  		motor[backl] = vexRT[Ch3]*0.25;
	  		motor[frontl] = vexRT[Ch3]*0.25;
			} else if ((abs(SensorValue[encoderR]) - abs(SensorValue[encoderL])) > 10){
				motor[backr] = vexRT[Ch2]*0.25;
	  		motor[frontr] = vexRT[Ch2]*0.25;
	  		motor[backl] = vexRT[Ch3];
	  		motor[frontl] = vexRT[Ch3];
			} else {*/
				motor[backr] = vexRT[Ch2]*0.78;
	  		motor[frontr] = vexRT[Ch2]*0.78;
	  		motor[backl] = vexRT[Ch3]*0.78;
	  		motor[frontl] = vexRT[Ch3]*0.78;
			//}

			/////////////////////////////////////////////////////////////////////////////////////////
      //
      //                                      FLYWHEEL
      //
      /////////////////////////////////////////////////////////////////////////////////////////
			startTask(FW_pidController);
			//startTask(spin_flywheel);

	  	if(vexRT[Btn8R] == 1){
				SensorValue[ledMed] = 1;
				SensorValue[ledHigh] = 1;
			}

  		if(vexRT[Btn5U] == 1){
				FW_running = true;
  		}

  		if(vexRT[Btn5D] == 1){
  			FW_running = false;
  		}

  		if(vexRT[Btn7L] == 1){
  			if(halfSpeedBtnPrsd == false){
  				if(FW_half){
	  				FW_half = false;
	  			} else {
	  				FW_half = true;
	  			}
  			}
  			halfSpeedBtnPrsd = true;
  		} else {
  			halfSpeedBtnPrsd = false;
  		}

  		if(vexRT[Btn7U] == 1){
  			if(highSpeedUpBtnPrsd == false){
  				FW_highSpeed = FW_highSpeed + 1;
  			}
  			highSpeedUpBtnPrsd = true;
  		} else {
  			highSpeedUpBtnPrsd = false;
  		}

  		if(vexRT[Btn7D] == 1){
  			if(highSpeedDownBtnPrsd == false){
  				FW_highSpeed = FW_highSpeed - 1;
  			}
  			highSpeedDownBtnPrsd = true;
  		} else {
  			highSpeedDownBtnPrsd = false;
  		}

      if(vexRT[Btn6U] == 1){
  			motor[bottomIntake] = 100;
  		} else if (vexRT[Btn6D] == 1){
        motor[bottomIntake] = -100;
      } else {
        motor[bottomIntake] = 0;
      }

  		if(vexRT[Btn7R] == 1){
      	FW_highSpeed = FW_highSpeedDefault;
  		}

      wait1Msec(10);
    }
	}
}
